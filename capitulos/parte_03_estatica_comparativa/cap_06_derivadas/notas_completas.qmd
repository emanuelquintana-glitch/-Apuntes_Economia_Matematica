---
title: "Capítulo 6: Estática Comparativa y el Concepto de Derivada"
subtitle: "Fundamentos de Economía Matemática"
author: 
  - name: "Emanuel Quintana Silva"
    affiliation: "Universidad Pedagógica y Tecnológica de Colombia (UPTC)"
    email: "emanuel.quintana@uptc.edu.co"
    orcid: "0009-0006-8419-2805"
date: "Febrero 2026"
date-format: "MMMM YYYY"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 4
    toc-location: left
    toc-title: "Contenido"
    number-sections: true
    number-depth: 4
    code-fold: show
    code-summary: "Mostrar código"
    code-tools: true
    code-copy: true
    code-overflow: wrap
    html-math-method: mathjax
    css: styles.css
    
  pdf:
    documentclass: book
    papersize: letter
    fontsize: 11pt
    geometry:
      - margin=1in
    number-sections: true
    toc: true
    toc-depth: 3
    colorlinks: true
    
execute:
  echo: true
  warning: false
  message: false
  cache: true
  
jupyter: python3
lang: es
---
```{python}
#| echo: false
#| output: false
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sympy as sp
from sympy import symbols, diff, limit, latex, simplify, solve, Abs
from sympy import init_printing, lambdify, oo, Rational
from IPython.display import display, Markdown, Latex, HTML
from matplotlib.patches import FancyArrowPatch
import warnings
warnings.filterwarnings('ignore')

# Configuración de gráficos
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 11
plt.rcParams['axes.grid'] = True
plt.rcParams['grid.alpha'] = 0.3
plt.rcParams['figure.dpi'] = 100

# Configuración de Sympy
sp.init_printing(use_latex='mathjax')

# Funciones auxiliares
def display_eq(eq, name=""):
    """Muestra una ecuación con formato LaTeX"""
    if name:
        display(Markdown(f"**{name}:**"))
    display(Latex(f"$${latex(eq)}$$"))

def plot_function_with_tangent(f, x0, x_range=(-5, 5), title=""):
    """Grafica función con recta tangente en x0"""
    x = symbols('x')
    f_num = lambdify(x, f, 'numpy')
    
    # Calcular derivada y tangente
    f_prime = diff(f, x)
    slope = f_prime.subs(x, x0)
    y0 = f.subs(x, x0)
    tangent = slope * (x - x0) + y0
    tangent_num = lambdify(x, tangent, 'numpy')
    
    # Graficar
    x_vals = np.linspace(x_range[0], x_range[1], 1000)
    
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.plot(x_vals, f_num(x_vals), 'b-', linewidth=2, label='$f(x)$')
    ax.plot(x_vals, tangent_num(x_vals), 'r--', linewidth=1.5, 
            label=f'Tangente en $x_0={x0}$')
    ax.plot(x0, float(y0), 'ro', markersize=8, label=f'Punto $(x_0, f(x_0))$')
    
    ax.axhline(y=0, color='k', linewidth=0.5)
    ax.axvline(x=0, color='k', linewidth=0.5)
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    if title:
        ax.set_title(title)
    
    plt.tight_layout()
    return fig

def plot_secant_to_tangent(f, x0, deltas, x_range=(-2, 5)):
    """Visualiza transición de secante a tangente"""
    x = symbols('x')
    f_num = lambdify(x, f, 'numpy')
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    axes = axes.flatten()
    
    for idx, delta in enumerate(deltas):
        ax = axes[idx]
        x_vals = np.linspace(x_range[0], x_range[1], 1000)
        
        # Función
        ax.plot(x_vals, f_num(x_vals), 'b-', linewidth=2, label='$f(x)$')
        
        # Puntos
        y0 = float(f.subs(x, x0))
        y1 = float(f.subs(x, x0 + delta))
        
        ax.plot(x0, y0, 'ro', markersize=8)
        ax.plot(x0 + delta, y1, 'go', markersize=8)
        
        # Secante
        slope_secant = (y1 - y0) / delta
        secant = lambda x_val: y0 + slope_secant * (x_val - x0)
        ax.plot(x_vals, secant(x_vals), 'r--', linewidth=1.5, 
                label=f'Secante ($\\Delta x = {delta}$)')
        
        ax.axhline(y=0, color='k', linewidth=0.5)
        ax.axvline(x=0, color='k', linewidth=0.5)
        ax.grid(True, alpha=0.3)
        ax.legend()
        ax.set_title(f'$\\Delta x = {delta}$')
        ax.set_xlabel('$x$')
        ax.set_ylabel('$y$')
    
    plt.tight_layout()
    return fig
```

::: {.callout-note icon=false}
## Información del Capítulo

**Basado en:** Chiang, A. C. & Wainwright, K. (2005). *Fundamental Methods of Mathematical Economics*. McGraw-Hill, Capítulo 6.

**Objetivo:** Introducir el concepto de derivada como herramienta fundamental para la estática comparativa, explicando su naturaleza como tasa de cambio instantánea y su interpretación geométrica.

**Contenido:**
- Naturaleza de la estática comparativa
- Cociente de diferencias y derivada
- Interpretación geométrica: pendiente de curvas
- Concepto de límite
- Continuidad y diferenciabilidad
:::

# Naturaleza de la Estática Comparativa

## Definición y Concepto Central

::: {.callout-important}
## Definición: Estática Comparativa

La **estática comparativa** se ocupa de **comparar diferentes estados de equilibrio** que resultan de cambios en los valores de los parámetros y las variables exógenas.

**Proceso:**
1. Se parte de un equilibrio inicial
2. Se introduce un cambio en algún parámetro
3. Se estudia el nuevo equilibrio resultante
4. Se compara el "antes" y el "después"
:::
```{python}
display(Markdown("""
### Ejemplo Conceptual: Modelo de Equilibrio de Mercado

Consideremos un mercado simple:

**Equilibrio Inicial:**
- Demanda: $Q_d = 100 - 2P$
- Oferta: $Q_s = 20 + 3P$
- Equilibrio: $P^* = 16$, $Q^* = 68$

**Cambio (aumento del ingreso):**
- Nueva Demanda: $Q_d = 120 - 2P$ (desplazamiento)
- Oferta sin cambio: $Q_s = 20 + 3P$
- Nuevo Equilibrio: $P^{**} = 20$, $Q^{**} = 80$

**Estática Comparativa:**
- $\\Delta P = 20 - 16 = 4$
- $\\Delta Q = 80 - 68 = 12$
"""))
```

## Lo que la Estática Comparativa IGNORA
```{python}
# Visualización conceptual
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Panel 1: Lo que SÍ estudia (equilibrios)
ax1 = axes[0]
P = np.linspace(0, 30, 100)
Q_d_inicial = 100 - 2*P
Q_s = 20 + 3*P
Q_d_nueva = 120 - 2*P

ax1.plot(Q_d_inicial, P, 'b-', linewidth=2, label='$D_0$')
ax1.plot(Q_s, P, 'r-', linewidth=2, label='$S$')
ax1.plot(Q_d_nueva, P, 'b--', linewidth=2, label='$D_1$')

ax1.plot(68, 16, 'ko', markersize=10, label='Equilibrio Inicial')
ax1.plot(80, 20, 'go', markersize=10, label='Equilibrio Final')

ax1.set_xlabel('Cantidad')
ax1.set_ylabel('Precio')
ax1.set_title('Estática Comparativa: Compara Estados de Equilibrio')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Panel 2: Lo que NO estudia (proceso de ajuste)
ax2 = axes[1]
tiempo = np.linspace(0, 10, 100)
P_ajuste = 16 + 4 * (1 - np.exp(-0.5*tiempo))
Q_ajuste = 68 + 12 * (1 - np.exp(-0.5*tiempo))

ax2.plot(tiempo, P_ajuste, 'b-', linewidth=2, label='Precio')
ax2.axhline(y=16, color='k', linestyle=':', linewidth=1, label='$P_0$')
ax2.axhline(y=20, color='g', linestyle=':', linewidth=1, label='$P_1$')
ax2.fill_between(tiempo, 16, 20, alpha=0.2, color='gray', 
                  label='Proceso ignorado')

ax2.set_xlabel('Tiempo')
ax2.set_ylabel('Precio')
ax2.set_title('Lo que se IGNORA: Proceso de Ajuste Temporal')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

display(Markdown("""
::: {.callout-warning}
## Limitaciones de la Estática Comparativa

La estática comparativa **NO considera:**

1. **El proceso de ajuste**: La trayectoria que siguen las variables
2. **La dimensión temporal**: El tiempo necesario para alcanzar el nuevo equilibrio
3. **La estabilidad**: Si el sistema realmente convergerá al nuevo equilibrio

Estos aspectos son objeto del **análisis dinámico**.
:::
"""))
```

## Análisis Cualitativo vs. Cuantitativo
```{python}
display(Markdown("""
### Tipos de Análisis Estático Comparativo

| Tipo | Pregunta | Ejemplo | Herramienta |
|------|----------|---------|-------------|
| **Cualitativo** | ¿En qué dirección cambia? | ¿Un aumento en la inversión aumenta o disminuye el ingreso? | Signo de $\\frac{dy}{dx}$ |
| **Cuantitativo** | ¿Cuánto cambia? | ¿Cuál es el valor exacto del multiplicador? | Magnitud de $\\frac{dy}{dx}$ |

::: {.callout-tip}
El análisis **cuantitativo** incluye automáticamente la información **cualitativa** a través del signo algebraico del resultado.
:::
"""))
```

## Herramienta Fundamental: La Derivada
```{python}
display(Markdown("""
::: {.callout-important}
## La Derivada en Estática Comparativa

Dado que el problema central es **encontrar la tasa de cambio del valor de equilibrio** de una variable endógena respecto a un parámetro, la herramienta matemática por excelencia es la **derivada**.

**Razón:** La derivada mide precisamente la **tasa de cambio instantánea**, que es exactamente lo que necesitamos para:

- Calcular multiplicadores
- Determinar sensibilidades
- Predecir impactos de políticas

**Tipos de derivadas utilizadas:**
- **Derivadas ordinarias**: Para funciones de una variable
- **Derivadas parciales**: Para modelos multivariables (ceteris paribus)
- **Teorema de la función implícita**: Para modelos sin solución explícita
:::
"""))
```

## Comparación: Estática, Estática Comparativa y Dinámica
```{python}
# Crear tabla comparativa
comparacion_df = pd.DataFrame({
    'Tipo de Análisis': ['Estática', 'Estática Comparativa', 'Dinámica'],
    'Pregunta Central': [
        '¿Dónde está el equilibrio?',
        '¿Cómo cambió el equilibrio?',
        '¿Cómo llegamos al equilibrio?'
    ],
    'Enfoque Temporal': [
        'Punto en el tiempo',
        'Antes vs. Después',
        'Proceso temporal completo'
    ],
    'Información': [
        'Valores de equilibrio',
        'Magnitud y dirección del cambio',
        'Trayectoria y velocidad de ajuste'
    ],
    'Herramienta Principal': [
        'Ecuaciones de equilibrio',
        'Derivadas y multiplicadores',
        'Ecuaciones diferenciales'
    ]
})

display(HTML(comparacion_df.to_html(index=False, escape=False)))

display(Markdown("""
::: {.callout-note}
## Relación entre los Enfoques

Los tres enfoques son complementarios:

1. **Estática**: Establece la base (equilibrios)
2. **Estática Comparativa**: Compara equilibrios (cambios)
3. **Dinámica**: Explica cómo se transita entre equilibrios (proceso)
:::
"""))
```

# La Tasa de Cambio y la Derivada

## El Cociente de Diferencias

::: {.callout-important}
## Definición: Cociente de Diferencias

Para una función $y = f(x)$, si $x$ cambia de $x_0$ a $x_0 + \Delta x$, el **cociente de diferencias** se define como:

$$\frac{\Delta y}{\Delta x} = \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}$$

**Interpretación:** 
- Mide la **tasa de cambio promedio** de $y$ respecto a $x$ en el intervalo $[x_0, x_0 + \Delta x]$
- Depende tanto de $x_0$ como de $\Delta x$
:::
```{python}
# Ejemplo numérico detallado
display(Markdown("""
### Ejemplo 6.1: Cálculo del Cociente de Diferencias

Dada la función $y = 3x^2 - 4$, calculemos el cociente de diferencias.
"""))

x, Dx = symbols('x Delta_x')
f = 3*x**2 - 4

# Calcular f(x + Δx)
f_shifted = f.subs(x, x + Dx)

display(Markdown("**Paso 1:** $f(x) = 3x^2 - 4$"))
display_eq(f, "Función original")

display(Markdown("**Paso 2:** $f(x + \\Delta x) = 3(x + \\Delta x)^2 - 4$"))
f_shifted_expanded = sp.expand(f_shifted)
display_eq(f_shifted_expanded, "Función desplazada (expandida)")

# Cociente de diferencias
delta_y = f_shifted_expanded - f
cociente = simplify(delta_y / Dx)

display(Markdown("**Paso 3:** Cociente de diferencias"))
display_eq(sp.Eq(symbols('Delta_y/Delta_x'), cociente), "Resultado")

display(Markdown(f"""
**Interpretación:**
- El cociente de diferencias es $\\frac{{\\Delta y}}{{\\Delta x}} = {latex(cociente)}$
- Depende de:
  - Punto inicial: $x$
  - Magnitud del cambio: $\\Delta x$
"""))

# Evaluación numérica
display(Markdown("### Evaluación Numérica"))
x_val, dx_val = 3, 4
cociente_num = cociente.subs([(x, x_val), (Dx, dx_val)])

display(Markdown(f"""
Para $x_0 = {x_val}$ y $\\Delta x = {dx_val}$:

$$\\frac{{\\Delta y}}{{\\Delta x}} = 6({x_val}) + 3({dx_val}) = {cociente_num}$$

Esto significa que, **en promedio**, $y$ aumenta {cociente_num} unidades por cada unidad de aumento en $x$ en ese intervalo.
"""))
```

### Interpretación Geométrica del Cociente de Diferencias
```{python}
# Visualización geométrica
x_sym = symbols('x')
f_ejemplo = 3*x_sym**2 - 4

x0_val = 2
delta_vals = [2, 1, 0.5]

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

for idx, dx_val in enumerate(delta_vals):
    ax = axes[idx]
    
    # Valores
    x_vals = np.linspace(-1, 5, 1000)
    f_num = lambdify(x_sym, f_ejemplo, 'numpy')
    
    # Puntos
    x0 = x0_val
    x1 = x0_val + dx_val
    y0 = float(f_ejemplo.subs(x_sym, x0))
    y1 = float(f_ejemplo.subs(x_sym, x1))
    
    # Pendiente de la secante
    slope = (y1 - y0) / dx_val
    
    # Graficar
    ax.plot(x_vals, f_num(x_vals), 'b-', linewidth=2, label='$f(x) = 3x^2 - 4$')
    ax.plot([x0, x1], [y0, y1], 'ro-', markersize=8, linewidth=2, 
            label='Secante')
    
    # Triángulo de cambio
    ax.plot([x0, x1], [y0, y0], 'g--', linewidth=1.5, alpha=0.7)
    ax.plot([x1, x1], [y0, y1], 'r--', linewidth=1.5, alpha=0.7)
    
    # Anotaciones
    ax.text(x0 + dx_val/2, y0 - 2, f'$\\Delta x = {dx_val}$', 
            ha='center', fontsize=10, color='green')
    ax.text(x1 + 0.3, (y0 + y1)/2, f'$\\Delta y = {y1-y0:.1f}$', 
            ha='left', fontsize=10, color='red')
    
    ax.set_title(f'$\\Delta x = {dx_val}$: Pendiente = {slope:.2f}')
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    ax.grid(True, alpha=0.3)
    ax.legend()

plt.tight_layout()
plt.show()

display(Markdown("""
::: {.callout-note}
## Interpretación Geométrica

El cociente de diferencias $\\frac{\\Delta y}{\\Delta x}$ representa la **pendiente de la línea secante** (cuerda) que une dos puntos sobre la curva:

- Punto A: $(x_0, f(x_0))$
- Punto B: $(x_0 + \\Delta x, f(x_0 + \\Delta x))$

**Observación:** A medida que $\\Delta x$ se hace más pequeño, la secante se aproxima a la tangente.
:::
"""))
```

## De la Tasa Promedio a la Tasa Instantánea: La Derivada
```{python}
display(Markdown("""
::: {.callout-important}
## Definición: La Derivada

La **derivada** de $f(x)$ en $x$ se define como el límite del cociente de diferencias cuando $\\Delta x$ tiende a cero:

$$\\frac{dy}{dx} = f'(x) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{f(x + \\Delta x) - f(x)}{\\Delta x}$$

**Características:**
- Representa la **tasa de cambio instantánea**
- Es el **límite** del cociente de diferencias
- Geométricamente, es la **pendiente de la recta tangente**
:::
"""))

# Ejemplo de cálculo de derivada
display(Markdown("### Ejemplo: Cálculo de la Derivada"))

x = symbols('x')
f_ej = 3*x**2 - 4

# Derivada simbólica
f_prime = diff(f_ej, x)

display(Markdown(f"""
**Función:** $f(x) = 3x^2 - 4$

**Proceso:**
1. Cociente de diferencias: $\\frac{{\\Delta y}}{{\\Delta x}} = 6x + 3\\Delta x$

2. Tomar el límite cuando $\\Delta x \\to 0$:
   $$f'(x) = \\lim_{{\\Delta x \\to 0}} (6x + 3\\Delta x) = 6x$$

**Resultado:**
"""))
display_eq(sp.Eq(symbols("f'(x)"), f_prime), "Derivada")

# Evaluaciones
x_vals = [0, 1, 2, 3, 4]
eval_data = []
for x_val in x_vals:
    deriv_val = f_prime.subs(x, x_val)
    eval_data.append({
        'x': x_val,
        "f'(x) = 6x": int(deriv_val),
        'Interpretación': f'Pendiente = {deriv_val} en x = {x_val}'
    })

display(HTML(pd.DataFrame(eval_data).to_html(index=False)))
```

### Visualización: De Secante a Tangente
```{python}
# Animación conceptual: secante → tangente
x_sym = symbols('x')
f = 3*x_sym**2 - 4
x0 = 2

deltas = [2.0, 1.0, 0.5, 0.1]

fig = plot_secant_to_tangent(f, x0, deltas, x_range=(-1, 5))
plt.show()

display(Markdown("""
::: {.callout-tip}
## Observación Clave

A medida que $\\Delta x$ se hace más pequeño:

1. La **secante** se acerca cada vez más a la **tangente**
2. La **pendiente de la secante** converge a la **pendiente de la tangente**
3. El **cociente de diferencias** converge a la **derivada**

$$\\text{Secante} \\xrightarrow{\\Delta x \\to 0} \\text{Tangente}$$
$$\\frac{\\Delta y}{\\Delta x} \\xrightarrow{\\Delta x \\to 0} \\frac{dy}{dx}$$
:::
"""))
```

## Función Primitiva vs. Función Derivada
```{python}
display(Markdown("""
::: {.callout-important}
## Distinción Fundamental

**Función Primitiva:** $y = f(x)$
- La función original

**Función Derivada:** $f'(x)$ o $\\frac{dy}{dx}$
- Una **nueva función** derivada de la original
- También depende de $x$
- Para cada valor de $x$, existe un valor único de la derivada

**Relación:**
- Si $f(x)$ representa un **total** (costo total, utilidad total)
- Entonces $f'(x)$ representa el **marginal** (costo marginal, utilidad marginal)
:::
"""))

# Ejemplo comparativo
x = symbols('x')
# Costo Total
CT = 50 + 10*x + 2*x**2
# Costo Marginal
CM = diff(CT, x)

display(Markdown("### Ejemplo Económico: Costo Total y Costo Marginal"))
display_eq(sp.Eq(symbols('CT(x)'), CT), "Función de Costo Total")
display_eq(sp.Eq(symbols('CM(x)'), CM), "Función de Costo Marginal")

# Tabla de valores
x_vals = np.arange(0, 11, 1)
ct_vals = [CT.subs(x, val) for val in x_vals]
cm_vals = [CM.subs(x, val) for val in x_vals]

df_costos = pd.DataFrame({
    'Cantidad (x)': x_vals,
    'Costo Total': ct_vals,
    'Costo Marginal': cm_vals
})

display(HTML(df_costos.to_html(index=False)))

# Gráfico
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Costo Total
x_plot = np.linspace(0, 10, 100)
ct_plot = [float(CT.subs(x, val)) for val in x_plot]
ax1.plot(x_plot, ct_plot, 'b-', linewidth=2)
ax1.set_xlabel('Cantidad')
ax1.set_ylabel('Costo Total ($)')
ax1.set_title('Función Primitiva: Costo Total')
ax1.grid(True, alpha=0.3)

# Costo Marginal
cm_plot = [float(CM.subs(x, val)) for val in x_plot]
ax2.plot(x_plot, cm_plot, 'r-', linewidth=2)
ax2.set_xlabel('Cantidad')
ax2.set_ylabel('Costo Marginal ($)')
ax2.set_title('Función Derivada: Costo Marginal')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Notaciones de la Derivada
```{python}
display(Markdown("""
### Notaciones Comunes

| Notación | Nombre | Énfasis | Uso |
|----------|--------|---------|-----|
| $f'(x)$ | Lagrange | La derivada es una función de $x$ | Cálculo general |
| $\\frac{dy}{dx}$ | Leibniz | Tasa de cambio (límite de $\\frac{\\Delta y}{\\Delta x}$) | Física, economía |
| $D_x f$ | Operador D | Operación de derivación | Matemática avanzada |
| $\\dot{y}$ | Newton | Derivada respecto al tiempo | Dinámica |

::: {.callout-note}
## Ventajas de cada notación

- **Lagrange** ($f'(x)$): Concisa, enfatiza que la derivada es una función
- **Leibniz** ($\\frac{dy}{dx}$): Intuitiva, muestra explícitamente las variables
- **Leibniz** es especialmente útil en estática comparativa para multiplicadores
:::
"""))
```

# Derivada y Pendiente de una Curva

## Interpretación Geométrica Fundamental
```{python}
import numpy as np
import matplotlib.pyplot as plt
from sympy import symbols, diff, lambdify, latex
from IPython.display import display, Markdown

display(Markdown("""
::: {.callout-important}
## Derivada = Pendiente de la Tangente

La derivada $f'(x_0)$ representa **geométricamente** la **pendiente de la recta tangente** a la curva $y = f(x)$ en el punto $(x_0, f(x_0))$.

**Comparación:**
- **Secante**: Une dos puntos → Pendiente = $\\frac{\\Delta y}{\\Delta x}$ (promedio)
- **Tangente**: "Toca" la curva en un solo punto → Pendiente = $\\frac{dy}{dx}$ (instantánea)

$$\\text{Pendiente de la tangente} = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} = f'(x_0)$$
:::
"""))

# Ejemplo visual detallado
x = symbols('x')
f = x**3 - 6*x**2 + 9*x + 1

x0_vals = [1, 2, 3]
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

for idx, x0 in enumerate(x0_vals):
    ax = axes[idx]
    
    # Función principal
    x_plot = np.linspace(-0.5, 4.5, 1000)
    f_num = lambdify(x, f, 'numpy')
    y_f = f_num(x_plot)
    
    # Derivada y cálculo de pendiente en el punto x0
    f_prime = diff(f, x)
    slope = float(f_prime.subs(x, x0))
    y0 = float(f.subs(x, x0))
    
    # Ecuación de la tangente: y = slope * (x - x0) + y0
    tangent_expr = slope * (x - x0) + y0
    tangent_num = lambdify(x, tangent_expr, 'numpy')
    
    # SOLUCIÓN AL ERROR: Forzar que el resultado sea un array
    y_tangent = tangent_num(x_plot)
    if np.isscalar(y_tangent):
        y_tangent = np.full_like(x_plot, y_tangent)
    
    # Graficar
    ax.plot(x_plot, y_f, 'b-', linewidth=2, label='$f(x)$')
    ax.plot(x_plot, y_tangent, 'r--', linewidth=1.5, 
            label=f'Tangente (m = {slope:.2f})')
    ax.plot(x0, y0, 'go', markersize=10, label=f'Punto $x_0 = {x0}$')
    
    # Estética de la gráfica
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    ax.set_title(f'$x_0 = {x0}$: $f\'(x_0) = {slope:.2f}$')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_xlim(-0.5, 4.5)
    ax.set_ylim(-2, 8)

plt.tight_layout()
plt.show()

display(Markdown(f"""
**Función:** $f(x) = {latex(f)}$

**Derivada:** $f'(x) = {latex(diff(f, x))}$

**Observaciones:**
- En **$x = 1$**: La pendiente es positiva ({float(f_prime.subs(x, 1)):.2f}), lo que indica que la función es creciente.
- En **$x = 2$**: La pendiente es negativa ({float(f_prime.subs(x, 2)):.2f}), lo que indica que la función es decreciente en ese punto.
- En **$x = 3$**: La pendiente es cero ({float(f_prime.subs(x, 3)):.2f}), lo que indica un punto crítico (mínimo local).
"""))
```

## Aplicación Económica: Análisis Marginal
```{python}
display(Markdown("""
::: {.callout-note}
## El Concepto "Marginal" en Economía

En economía, la derivada se identifica directamente con el **análisis marginal**:

| Función Total | Derivada (Función Marginal) | Interpretación |
|---------------|----------------------------|----------------|
| Costo Total $C(Q)$ | Costo Marginal $CM = C'(Q)$ | Costo de producir una unidad adicional |
| Ingreso Total $I(Q)$ | Ingreso Marginal $IM = I'(Q)$ | Ingreso por vender una unidad adicional |
| Utilidad Total $U(Q)$ | Utilidad Marginal $UM = U'(Q)$ | Utilidad de consumir una unidad adicional |
| Producto Total $PT(L)$ | Producto Marginal $PM_L = PT'(L)$ | Producto adicional del último trabajador |
:::
"""))

# Ejemplo: Costo Marginal
Q = symbols('Q')
C = 100 + 50*Q - 5*Q**2 + 0.5*Q**3
CM = diff(C, Q)

display(Markdown("### Ejemplo: Costo Total y Costo Marginal"))
display_eq(sp.Eq(symbols('C(Q)'), C), "Costo Total")
display_eq(sp.Eq(symbols('CM(Q)'), CM), "Costo Marginal")

# Gráfico dual
Q_vals = np.linspace(0, 12, 100)
C_vals = [float(C.subs(Q, q)) for q in Q_vals]
CM_vals = [float(CM.subs(Q, q)) for q in Q_vals]

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))

# Panel superior: Costo Total con tangentes
ax1.plot(Q_vals, C_vals, 'b-', linewidth=2, label='Costo Total $C(Q)$')

# Dibujar tangentes en algunos puntos
for q0 in [2, 5, 8]:
    c0 = float(C.subs(Q, q0))
    slope = float(CM.subs(Q, q0))
    tangent = lambda q: c0 + slope * (q - q0)
    Q_tang = np.linspace(q0 - 1.5, q0 + 1.5, 50)
    ax1.plot(Q_tang, tangent(Q_tang), 'r--', linewidth=1, alpha=0.6)
    ax1.plot(q0, c0, 'ro', markersize=6)
    ax1.text(q0, c0 + 20, f'$CM={slope:.1f}$', ha='center', fontsize=9)

ax1.set_xlabel('Cantidad $Q$')
ax1.set_ylabel('Costo Total ($)')
ax1.set_title('Costo Total (las tangentes muestran el Costo Marginal)')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Panel inferior: Costo Marginal
ax2.plot(Q_vals, CM_vals, 'r-', linewidth=2, label='Costo Marginal $CM(Q)$')
ax2.axhline(y=0, color='k', linewidth=0.5)
ax2.set_xlabel('Cantidad $Q$')
ax2.set_ylabel('Costo Marginal ($)')
ax2.set_title('Costo Marginal = Pendiente de la Curva de Costo Total')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

display(Markdown("""
::: {.callout-tip}
## Interpretación

El **Costo Marginal** en cualquier nivel de producción $Q_0$ es:
- **Algebraicamente**: El valor de la derivada $CM(Q_0) = C'(Q_0)$
- **Geométricamente**: La pendiente de la tangente a la curva de costo total en $Q_0$
- **Económicamente**: El costo aproximado de producir una unidad adicional en $Q_0$
:::
"""))
```

## Aproximación Lineal mediante la Derivada
```{python}
display(Markdown("""
::: {.callout-important}
## Aproximación Lineal

Cerca del punto de tangencia, la curva y su línea tangente son casi idénticas. Esto permite usar la derivada para aproximar valores de la función:

$$f(x) \\approx f(x_0) + f'(x_0)(x - x_0)$$

**Componentes:**
- $f(x_0)$: Valor inicial conocido
- $f'(x_0)$: Pendiente (tasa de cambio)
- $(x - x_0)$: Desplazamiento desde el punto inicial

**Diferenciales:**
- $dx = \\Delta x$: Cambio en $x$
- $dy = f'(x_0) dx$: Cambio **aproximado** en $y$ (a lo largo de la tangente)
- $\\Delta y$: Cambio **real** en $y$ (a lo largo de la curva)
:::
"""))

# Ejemplo numérico
x = symbols('x')
f = x**2 + 3*x + 1

x0 = 2
dx_val = 0.5

f_x0 = float(f.subs(x, x0))
f_prime = diff(f, x)
slope = float(f_prime.subs(x, x0))

# Aproximación
y_approx = f_x0 + slope * dx_val
# Valor real
y_real = float(f.subs(x, x0 + dx_val))
# Error
error = abs(y_real - y_approx)

display(Markdown(f"""
### Ejemplo Numérico: Aproximación Lineal

**Función:** $f(x) = x^2 + 3x + 1$

**Punto base:** $x_0 = {x0}$, donde $f(x_0) = {f_x0}$

**Derivada:** $f'(x) = {latex(f_prime)}$, entonces $f'({x0}) = {slope}$

**Cambio:** $dx = {dx_val}$

**Aproximación lineal:**
$$f({x0 + dx_val}) \\approx {f_x0} + {slope} \\times {dx_val} = {y_approx}$$

**Valor real:**
$$f({x0 + dx_val}) = {y_real}$$

**Error de aproximación:** ${error:.6f}$

::: {{.callout-note}}
Para cambios pequeños ($dx$ cercano a 0), la aproximación lineal es muy precisa.
:::
"""))

# Visualización
fig, ax = plt.subplots(figsize=(10, 6))

x_plot = np.linspace(0, 5, 1000)
f_num = lambdify(x, f, 'numpy')

# Función
ax.plot(x_plot, f_num(x_plot), 'b-', linewidth=2, label='$f(x) = x^2 + 3x + 1$')

# Tangente
tangent = slope * (x - x0) + f_x0
tangent_num = lambdify(x, tangent, 'numpy')
ax.plot(x_plot, tangent_num(x_plot), 'r--', linewidth=1.5, label='Aproximación lineal')

# Puntos
ax.plot(x0, f_x0, 'go', markersize=10, label=f'Punto base $(x_0, f(x_0))$')
ax.plot(x0 + dx_val, y_approx, 'ro', markersize=8, label=f'Aproximación')
ax.plot(x0 + dx_val, y_real, 'bs', markersize=8, label=f'Valor real')

# Líneas verticales mostrando diferencia
ax.plot([x0 + dx_val, x0 + dx_val], [y_approx, y_real], 'k:', linewidth=2)
ax.text(x0 + dx_val + 0.1, (y_approx + y_real)/2, f'Error = {error:.4f}', 
        fontsize=10)

ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
ax.set_title('Aproximación Lineal usando la Derivada')
ax.legend()
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Signos de la Derivada e Interpretación
```{python}
display(Markdown("""
::: {.callout-important}
## Interpretación del Signo de la Derivada

El signo de $f'(x)$ indica el comportamiento de la función:

| Derivada | Pendiente | Comportamiento | Interpretación Económica |
|----------|-----------|----------------|-------------------------|
| $f'(x) > 0$ | Positiva | Función **creciente** | Relación directa (ej: más trabajo → más producto) |
| $f'(x) = 0$ | Cero | Punto **estacionario** | Máximo, mínimo o punto de inflexión |
| $f'(x) < 0$ | Negativa | Función **decreciente** | Relación inversa (ej: más precio → menos demanda) |
:::
"""))

# Ejemplo visual
x = symbols('x')
f = -0.5*x**3 + 3*x**2 - 2*x + 1
f_prime = diff(f, x)

# Encontrar puntos críticos
puntos_criticos = solve(f_prime, x)

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

x_plot = np.linspace(-1, 5, 1000)
f_num = lambdify(x, f, 'numpy')
f_prime_num = lambdify(x, f_prime, 'numpy')

# Panel 1: Función
ax1.plot(x_plot, f_num(x_plot), 'b-', linewidth=2, label='$f(x)$')
ax1.axhline(y=0, color='k', linewidth=0.5)

# Marcar puntos críticos
for pc in puntos_criticos:
    if pc.is_real:
        pc_float = float(pc)
        if -1 <= pc_float <= 5:
            y_crit = float(f.subs(x, pc))
            ax1.plot(pc_float, y_crit, 'ro', markersize=10)
            ax1.text(pc_float, y_crit + 0.5, f'$x = {pc_float:.2f}$', 
                    ha='center', fontsize=9)

ax1.set_xlabel('$x$')
ax1.set_ylabel('$f(x)$')
ax1.set_title('Función $f(x)$')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Panel 2: Derivada
ax2.plot(x_plot, f_prime_num(x_plot), 'r-', linewidth=2, label="$f'(x)$")
ax2.axhline(y=0, color='k', linewidth=1)
ax2.fill_between(x_plot, 0, f_prime_num(x_plot), 
                  where=(f_prime_num(x_plot) > 0), alpha=0.3, 
                  color='green', label='$f\'(x) > 0$ (creciente)')
ax2.fill_between(x_plot, 0, f_prime_num(x_plot), 
                  where=(f_prime_num(x_plot) < 0), alpha=0.3, 
                  color='red', label='$f\'(x) < 0$ (decreciente)')

# Marcar ceros de la derivada
for pc in puntos_criticos:
    if pc.is_real:
        pc_float = float(pc)
        if -1 <= pc_float <= 5:
            ax2.plot(pc_float, 0, 'ko', markersize=8)

ax2.set_xlabel('$x$')
ax2.set_ylabel("$f'(x)$")
ax2.set_title('Derivada $f\'(x)$ (indica crecimiento/decrecimiento)')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

display(Markdown(f"""
**Función:** $f(x) = {latex(f)}$

**Derivada:** $f'(x) = {latex(f_prime)}$

**Puntos críticos** (donde $f'(x) = 0$): {', '.join([f'$x = {float(pc):.3f}$' for pc in puntos_criticos if pc.is_real])}

**Interpretación:**
- Cuando $f'(x) > 0$: La función está **creciendo** (zona verde)
- Cuando $f'(x) = 0$: Puntos **críticos** (posibles máximos/mínimos)
- Cuando $f'(x) < 0$: La función está **decreciendo** (zona roja)
"""))
```

# Concepto de Límite

## Definición Intuitiva
```{python}
display(Markdown("""
::: {.callout-important}
## Definición: Límite

El **límite** de una función $q = g(v)$ cuando $v$ tiende a $N$ es el valor $L$ al que se aproxima $q$ a medida que $v$ se acerca a $N$ (sin necesariamente alcanzarlo).

**Notación:**
$$\\lim_{v \\to N} g(v) = L$$

**Significado:** 
- "Cuando $v$ se acerca a $N$, $g(v)$ se acerca a $L$"
- $v$ puede aproximarse a $N$ desde valores menores (izquierda) o mayores (derecha)
- $L$ debe ser un número real finito
:::
"""))
```

## Límites Laterales
```{python}
display(Markdown("""
::: {.callout-important}
## Límites Izquierdo y Derecho

**Límite izquierdo** ($v \\to N^-$):
- $v$ se aproxima a $N$ desde valores **menores** (por la izquierda)
- Notación: $\\lim_{v \\to N^-} g(v) = L_i$

**Límite derecho** ($v \\to N^+$):
- $v$ se aproxima a $N$ desde valores **mayores** (por la derecha)
- Notación: $\\lim_{v \\to N^+} g(v) = L_d$

**Condición de existencia:**
$$\\lim_{v \\to N} g(v) = L \\quad \\Leftrightarrow \\quad L_i = L_d = L$$

El límite existe si y solo si los límites laterales son **iguales** y **finitos**.
:::
"""))

# Ejemplo visual de límites laterales
v = symbols('v')

# Función con límites laterales iguales
f1 = v**2 - 4

# Función con salto (límites laterales diferentes)
from sympy import Piecewise
f2 = Piecewise((v + 1, v < 2), (v + 3, v >= 2))

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Panel 1: Límites laterales iguales
ax1 = axes[0]
v_vals = np.linspace(-1, 5, 1000)
f1_num = lambdify(v, f1, 'numpy')

ax1.plot(v_vals, f1_num(v_vals), 'b-', linewidth=2)
N = 2
L = float(f1.subs(v, N))
ax1.plot(N, L, 'ro', markersize=10, label=f'Límite = {L}')

# Flechas indicando aproximación
ax1.annotate('', xy=(N, L), xytext=(N-1, f1_num(N-1)),
            arrowprops=dict(arrowstyle='->', color='green', lw=2))
ax1.annotate('', xy=(N, L), xytext=(N+1, f1_num(N+1)),
            arrowprops=dict(arrowstyle='->', color='green', lw=2))

ax1.set_xlabel('$v$')
ax1.set_ylabel('$g(v)$')
ax1.set_title('Límite Existe: $L_i = L_d$')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Panel 2: Límites laterales diferentes (función escalón)
ax2 = axes[1]
v_left = np.linspace(0, 1.99, 100)
v_right = np.linspace(2, 4, 100)

ax2.plot(v_left, v_left + 1, 'b-', linewidth=2)
ax2.plot(v_right, v_right + 3, 'b-', linewidth=2)

# Marcar discontinuidad
N = 2
L_i = 3  # límite por izquierda
L_d = 5  # límite por derecha

ax2.plot(N, L_i, 'go', markersize=8, label=f'$L_i = {L_i}$')
ax2.plot(N, L_d, 'bs', markersize=8, label=f'$L_d = {L_d}$')
ax2.plot([N, N], [L_i, L_d], 'r:', linewidth=2)

ax2.set_xlabel('$v$')
ax2.set_ylabel('$g(v)$')
ax2.set_title('Límite NO Existe: $L_i \\neq L_d$')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Ilustraciones Gráficas de Límites
```{python}
# Recrear la Figura 6.2 del texto
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (a) Curva lisa - Límite existe
ax1 = axes[0, 0]
v_vals = np.linspace(-2, 4, 1000)
g1 = lambda v: -0.3*(v - 1)**2 + 3
ax1.plot(v_vals, g1(v_vals), 'b-', linewidth=2)
N, L = 1, 3
ax1.plot(N, L, 'ro', markersize=10)
ax1.axhline(y=L, color='g', linestyle=':', linewidth=1, alpha=0.7)
ax1.axvline(x=N, color='g', linestyle=':', linewidth=1, alpha=0.7)
ax1.text(N + 0.3, L + 0.3, f'$L = {L}$', fontsize=12)
ax1.set_title('(a) Curva lisa: $\\lim_{v \\to N} g(v) = L$')
ax1.grid(True, alpha=0.3)

# (b) Punto picudo - Límite existe
ax2 = axes[0, 1]
v_vals = np.linspace(-1, 3, 1000)
N = 1
g2_left = lambda v: 2*v + 1
g2_right = lambda v: -v + 4

v_left = v_vals[v_vals <= N]
v_right = v_vals[v_vals >= N]

ax2.plot(v_left, g2_left(v_left), 'b-', linewidth=2)
ax2.plot(v_right, g2_right(v_right), 'b-', linewidth=2)
L = 3
ax2.plot(N, L, 'ro', markersize=10)
ax2.axhline(y=L, color='g', linestyle=':', linewidth=1, alpha=0.7)
ax2.axvline(x=N, color='g', linestyle=':', linewidth=1, alpha=0.7)
ax2.text(N + 0.2, L + 0.2, f'$L = {L}$', fontsize=12)
ax2.set_title('(b) Punto picudo: Límite existe pero no diferenciable')
ax2.grid(True, alpha=0.3)

# (c) Función escalón - Límite NO existe
ax3 = axes[1, 0]
v_vals = np.linspace(-1, 3, 1000)
N = 1
L1, L2 = 1, 2.5

v_left = v_vals[v_vals < N]
v_right = v_vals[v_vals >= N]

ax3.plot(v_left, np.ones_like(v_left) * L1, 'b-', linewidth=2)
ax3.plot(v_right, np.ones_like(v_right) * L2, 'b-', linewidth=2)
ax3.plot(N, L1, 'go', markersize=8, label=f'$L_1 = {L1}$')
ax3.plot(N, L2, 'bs', markersize=8, label=f'$L_2 = {L2}$')
ax3.plot([N, N], [L1, L2], 'r:', linewidth=2)
ax3.axvline(x=N, color='r', linestyle=':', linewidth=1, alpha=0.7)
ax3.set_title('(c) Función escalón: $L_1 \\neq L_2$, límite NO existe')
ax3.legend()
ax3.grid(True, alpha=0.3)

# (d) Límites infinitos - Asíntota vertical
ax4 = axes[1, 1]
v_vals = np.linspace(-2, 4, 1000)
N = 1
# Función hiperbólica con asíntota en v=1
g4 = lambda v: 1 / (v - N) + 2

# Dividir en dos regiones para evitar la discontinuidad
v_left = v_vals[v_vals < N - 0.01]
v_right = v_vals[v_vals > N + 0.01]

ax4.plot(v_left, g4(v_left), 'b-', linewidth=2)
ax4.plot(v_right, g4(v_right), 'b-', linewidth=2)
ax4.axvline(x=N, color='r', linestyle='--', linewidth=2, 
            label='Asíntota vertical')
ax4.axhline(y=2, color='g', linestyle='--', linewidth=1.5, 
            label='Asíntota horizontal $M=2$')
ax4.set_ylim(-5, 10)
ax4.set_title('(d) Límites infinitos: $\\lim_{v \\to N} g(v)$ no existe')
ax4.legend()
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

display(Markdown("""
::: {.callout-note}
## Análisis de las Ilustraciones

**(a) Curva lisa:** Límite existe ($L_i = L_d = L$)

**(b) Punto picudo:** Límite existe, pero la función **no es diferenciable** (no hay tangente única)

**(c) Función escalón:** Límite **no existe** porque $L_1 \\neq L_2$

**(d) Límites infinitos:** Cuando $v \\to N$, $g(v) \\to \\pm\\infty$ (no hay límite finito). Sin embargo, cuando $v \\to \\pm\\infty$, $g(v) \\to M$ (límite horizontal existe)
:::
"""))
```

## Evaluación de Límites
```{python}
display(Markdown("""
### Métodos para Evaluar Límites

::: {.callout-tip}
## 1. Sustitución Directa (para funciones continuas)

Si $g(v)$ es continua en $N$:
$$\\lim_{v \\to N} g(v) = g(N)$$

**Válido para:** funciones polinomiales, exponenciales, logarítmicas (en su dominio)
:::

::: {.callout-warning}
## 2. Transformación Algebraica (forma indeterminada $\\frac{0}{0}$)

Si la sustitución directa da $\\frac{0}{0}$:
1. **Factorizar** y simplificar
2. **Eliminar** el término problemático
3. **Evaluar** el límite de la expresión simplificada

**Ejemplo:**
$$\\lim_{v \\to 1} \\frac{v^2 - 1}{v - 1} = \\lim_{v \\to 1} \\frac{(v-1)(v+1)}{v-1} = \\lim_{v \\to 1} (v+1) = 2$$
:::

::: {.callout-note}
## 3. Límites al Infinito

Para $v \\to \\infty$:
1. **Dividir** numerador y denominador por la mayor potencia de $v$
2. Términos con $v$ en el denominador → 0
3. Evaluar el límite resultante

**Ejemplo:**
$$\\lim_{v \\to \\infty} \\frac{3v^2 + 2v}{v^2 - 5} = \\lim_{v \\to \\infty} \\frac{3 + \\frac{2}{v}}{1 - \\frac{5}{v^2}} = \\frac{3 + 0}{1 - 0} = 3$$
:::
"""))

# Ejemplos prácticos
v = symbols('v')

# Ejemplo 1: Sustitución directa
f1 = v**2 + 3*v - 2
N1 = 2
lim1 = limit(f1, v, N1)

display(Markdown(f"""
### Ejemplo 1: Sustitución Directa

**Función:** $g(v) = {latex(f1)}$

**Límite:** $\\lim_{{v \\to {N1}}} g(v)$

**Solución:** Como es un polinomio (función continua):
$$\\lim_{{v \\to {N1}}} ({latex(f1)}) = {latex(f1.subs(v, N1))} = {lim1}$$
"""))

# Ejemplo 2: Forma indeterminada
f2_num = v**2 - 1
f2_den = v - 1
f2 = f2_num / f2_den

N2 = 1
# Factorización
f2_simplified = simplify(f2)
lim2 = limit(f2, v, N2)

display(Markdown(f"""
### Ejemplo 2: Forma Indeterminada $\\frac{{0}}{{0}}$

**Función:** $g(v) = \\frac{{{latex(f2_num)}}}{{{latex(f2_den)}}}$

**Límite:** $\\lim_{{v \\to {N2}}} g(v)$

**Problema:** Sustitución directa da $\\frac{{0}}{{0}}$ (indeterminado)

**Solución:**
1. Factorizar: $\\frac{{v^2 - 1}}{{v - 1}} = \\frac{{(v-1)(v+1)}}{{v-1}}$

2. Simplificar: $= v + 1$ (para $v \\neq 1$)

3. Evaluar: $\\lim_{{v \\to {N2}}} (v + 1) = {lim2}$
"""))

# Visualización
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1
ax1 = axes[0]
v_vals = np.linspace(-1, 5, 1000)
f1_num = lambdify(v, f1, 'numpy')
ax1.plot(v_vals, f1_num(v_vals), 'b-', linewidth=2)
ax1.plot(N1, float(lim1), 'ro', markersize=10, label=f'Límite = {lim1}')
ax1.set_xlabel('$v$')
ax1.set_ylabel('$g(v)$')
ax1.set_title('Ejemplo 1: Límite por sustitución')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Gráfico 2
ax2 = axes[1]
v_vals2 = np.linspace(-2, 4, 1000)
# Evitar v=1
v_vals2 = v_vals2[np.abs(v_vals2 - 1) > 0.01]
f2_num_func = lambdify(v, f2_simplified, 'numpy')
ax2.plot(v_vals2, f2_num_func(v_vals2), 'b-', linewidth=2)
ax2.plot(N2, float(lim2), 'ro', markersize=10, 
         label=f'Límite = {lim2}', zorder=5)
# Hueco en v=1 (función no definida)
ax2.plot(N2, float(lim2), 'wo', markersize=8, 
         markeredgecolor='red', markeredgewidth=2, zorder=6)
ax2.set_xlabel('$v$')
ax2.set_ylabel('$g(v)$')
ax2.set_title('Ejemplo 2: Límite tras simplificación')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Punto de Vista Formal: Definición Épsilon-Delta
```{python}
display(Markdown("""
::: {.callout-important}
## Definición Formal de Límite (Épsilon-Delta)

$$\\lim_{v \\to N} g(v) = L$$

**significa:** Para cada $\\varepsilon > 0$ (por pequeño que sea), existe un $\\delta > 0$ tal que:

$$\\text{Si } 0 < |v - N| < \\delta \\quad \\Rightarrow \\quad |g(v) - L| < \\varepsilon$$

**Interpretación:**
- $\\varepsilon$: Tolerancia de error en $g(v)$ (qué tan cerca queremos que $g(v)$ esté de $L$)
- $\\delta$: Cercanía requerida de $v$ a $N$ (qué tan cerca debe estar $v$ de $N$)
- Para cualquier precisión $\\varepsilon$ que exijamos, podemos encontrar una vecindad $\\delta$ de $N$ que la garantice

**Propiedades clave:**
1. $\\delta$ depende de $\\varepsilon$ (generalmente, $\\varepsilon$ más pequeño requiere $\\delta$ más pequeño)
2. No importa el valor de $g(N)$ (puede ni siquiera estar definida en $N$)
3. El límite, si existe, es **único**
:::
"""))

# Visualización conceptual épsilon-delta
fig, ax = plt.subplots(figsize=(12, 8))

# Función simple
v_vals = np.linspace(0, 4, 1000)
g = lambda v: 2*v + 1
N, L = 2, 5

# Graficar función
ax.plot(v_vals, g(v_vals), 'b-', linewidth=2, label='$g(v) = 2v + 1$')

# Valores de epsilon y delta
epsilon = 1.0
delta = epsilon / 2  # Para esta función lineal, delta = epsilon/pendiente

# Banda horizontal (epsilon)
ax.fill_between(v_vals, L - epsilon, L + epsilon, alpha=0.2, color='red',
                 label=f'Banda $\\varepsilon = {epsilon}$ alrededor de $L$')
ax.axhline(y=L - epsilon, color='r', linestyle='--', linewidth=1)
ax.axhline(y=L + epsilon, color='r', linestyle='--', linewidth=1)
ax.axhline(y=L, color='r', linestyle='-', linewidth=1.5)

# Banda vertical (delta)
ax.fill_betweenx([0, 10], N - delta, N + delta, alpha=0.2, color='green',
                  label=f'Banda $\\delta = {delta}$ alrededor de $N$')
ax.axvline(x=N - delta, color='g', linestyle='--', linewidth=1)
ax.axvline(x=N + delta, color='g', linestyle='--', linewidth=1)
ax.axvline(x=N, color='g', linestyle='-', linewidth=1.5)

# Punto límite
ax.plot(N, L, 'ro', markersize=12, zorder=5)

# Anotaciones
ax.text(N + 0.1, L + 0.3, f'$(N, L) = ({N}, {L})$', fontsize=12)
ax.text(N + delta + 0.1, 2, f'$\\delta = {delta}$', fontsize=11, color='green')
ax.text(0.5, L + epsilon + 0.3, f'$\\varepsilon = {epsilon}$', fontsize=11, color='red')

ax.set_xlim(0, 4)
ax.set_ylim(0, 10)
ax.set_xlabel('$v$')
ax.set_ylabel('$g(v)$')
ax.set_title('Definición Formal de Límite: $\\forall \\varepsilon > 0, \\exists \\delta > 0$ tal que si $|v - N| < \\delta$ entonces $|g(v) - L| < \\varepsilon$')
ax.legend(loc='upper left')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

display(Markdown("""
::: {.callout-note}
## Interpretación Gráfica

La "caja" formada por las bandas $\\varepsilon$ (horizontal) y $\\delta$ (vertical) ilustra la definición:

- Para cualquier banda horizontal $\\varepsilon$ alrededor de $L$ que elijamos...
- ...podemos encontrar una banda vertical $\\delta$ alrededor de $N$...
- ...tal que la curva **entra** por los lados de la caja (zona verde) y **sale** por los lados (zona verde), nunca cruzando las bandas superior/inferior (rojas)

Esto garantiza que $g(v)$ esté dentro de $\\varepsilon$ de $L$ siempre que $v$ esté dentro de $\\delta$ de $N$.
:::
"""))
```

# Ejercicios Resueltos

## Ejercicio 6.2: Cociente de Diferencias y Derivada
```{python}
display(Markdown("""
### Ejercicio 6.2

Resolver problemas de cociente de diferencias y derivadas para las siguientes funciones:
"""))

# Problema 1
display(Markdown("#### Problema 1: $y = 4x^2 + 9$"))

x, Dx = symbols('x Delta_x')
y1 = 4*x**2 + 9

# (a) Cociente de diferencias
y1_shifted = y1.subs(x, x + Dx)
delta_y1 = sp.expand(y1_shifted - y1)
cociente1 = simplify(delta_y1 / Dx)

display(Markdown("**(a) Cociente de diferencias:**"))
display_eq(sp.Eq(symbols('Delta_y/Delta_x'), cociente1))

# (b) Derivada
derivada1 = diff(y1, x)
display(Markdown("**(b) Derivada:**"))
display_eq(sp.Eq(symbols('dy/dx'), derivada1))

# (c) Evaluaciones
f_prime_3 = derivada1.subs(x, 3)
f_prime_4 = derivada1.subs(x, 4)

display(Markdown(f"""
**(c) Evaluaciones:**
- $f'(3) = {f_prime_3}$
- $f'(4) = {f_prime_4}$
"""))

# Problema 2
display(Markdown("#### Problema 2: $y = 5x^2 - 4x$"))

y2 = 5*x**2 - 4*x

# (a) Cociente de diferencias
y2_shifted = y2.subs(x, x + Dx)
delta_y2 = sp.expand(y2_shifted - y2)
cociente2 = simplify(delta_y2 / Dx)

display(Markdown("**(a) Cociente de diferencias:**"))
display_eq(sp.Eq(symbols('Delta_y/Delta_x'), cociente2))

# (b) Derivada
derivada2 = diff(y2, x)
display(Markdown("**(b) Derivada:**"))
display_eq(sp.Eq(symbols('dy/dx'), derivada2))

# (c) Evaluaciones
f_prime_2 = derivada2.subs(x, 2)
f_prime_3_2 = derivada2.subs(x, 3)

display(Markdown(f"""
**(c) Evaluaciones:**
- $f'(2) = {f_prime_2}$
- $f'(3) = {f_prime_3_2}$
"""))

# Problema 3
display(Markdown("#### Problema 3: $y = 5x - 2$"))

y3 = 5*x - 2

# (a) Cociente de diferencias
y3_shifted = y3.subs(x, x + Dx)
delta_y3 = y3_shifted - y3
cociente3 = simplify(delta_y3 / Dx)

display(Markdown(f"""
**(a) Cociente de diferencias:**

$$\\frac{{\\Delta y}}{{\\Delta x}} = \\frac{{5(x + \\Delta x) - 2 - (5x - 2)}}{{\\Delta x}} = \\frac{{5\\Delta x}}{{\\Delta x}} = {cociente3}$$

**Tipo de función:** Lineal (constante de proporcionalidad)
"""))

display(Markdown(f"""
**(b) Importancia de $\\Delta x$:**

Como la expresión $\\Delta x$ se cancela, su magnitud **no importa** para el valor del cociente de diferencias.

El límite cuando $\\Delta x \\to 0$ es simplemente: ${cociente3}$

::: {{.callout-note}}
Para funciones **lineales**, la tasa de cambio es **constante** (igual a la pendiente), independientemente del intervalo considerado.
:::
"""))
```

## Ejercicio 6.4: Evaluación de Límites
```{python}
display(Markdown("### Ejercicio 6.4"))

# Problema 1
display(Markdown("#### Problema 1: $q = \\frac{v^2 + v - 56}{v - 7}$, $(v \\neq 7)$"))

v = symbols('v')
q1_num = v**2 + v - 56
q1_den = v - 7
q1 = q1_num / q1_den

# Factorizar numerador
q1_num_factored = sp.factor(q1_num)
display(Markdown(f"""
**Factorización del numerador:**
$${latex(q1_num)} = {latex(q1_num_factored)}$$
"""))

# Simplificar
q1_simplified = simplify(q1)
display(Markdown(f"""
**Simplificación:**
$$q = \\frac{{{latex(q1_num_factored)}}}{{{latex(q1_den)}}} = {latex(q1_simplified)} \\quad (v \\neq 7)$$
"""))

# Límites laterales
lim_left = limit(q1, v, 7, '-')
lim_right = limit(q1, v, 7, '+')
lim_total = limit(q1, v, 7)

display(Markdown(f"""
**Límites:**
- Límite izquierdo: $\\lim_{{v \\to 7^-}} q = {lim_left}$
- Límite derecho: $\\lim_{{v \\to 7^+}} q = {lim_right}$

**Conclusión:** Como $L_i = L_d = {lim_total}$, el límite **existe** y vale ${lim_total}$.
"""))

# Problema 2
display(Markdown("#### Problema 2: $q = \\frac{(v+2)^3 - 8}{v}$, $(v \\neq 0)$"))

q2_num = (v + 2)**3 - 8
q2_den = v
q2 = q2_num / q2_den

# Expandir y simplificar
q2_num_expanded = sp.expand(q2_num)
q2_simplified = simplify(q2)

display(Markdown(f"""
**Expansión:**
$$(v + 2)^3 = {latex(sp.expand((v+2)**3))}$$

**Numerador:**
$${latex(q2_num)} = {latex(q2_num_expanded)}$$

**Simplificación:**
$$q = \\frac{{{latex(q2_num_expanded)}}}{{{latex(q2_den)}}} = {latex(q2_simplified)} \\quad (v \\neq 0)$$
"""))

# Evaluar límites
lim_0 = limit(q2, v, 0)
lim_2 = limit(q2, v, 2)
a_sym = symbols('a')
lim_a = limit(q2, v, a_sym)

display(Markdown(f"""
**(a)** $\\lim_{{v \\to 0}} q = {lim_0}$

**(b)** $\\lim_{{v \\to 2}} q = {lim_2}$

**(c)** $\\lim_{{v \\to a}} q = {latex(lim_a)}$
"""))

# Problema 3
display(Markdown("#### Problema 3: $q = 5 - \\frac{1}{v}$, $(v \\neq 0)$"))

q3 = 5 - 1/v

lim_inf = limit(q3, v, oo)
lim_minf = limit(q3, v, -oo)

display(Markdown(f"""
**(a)** $\\lim_{{v \\to \\infty}} q = \\lim_{{v \\to \\infty}} \\left(5 - \\frac{{1}}{{v}}\\right) = 5 - 0 = {lim_inf}$

**(b)** $\\lim_{{v \\to -\\infty}} q = \\lim_{{v \\to -\\infty}} \\left(5 - \\frac{{1}}{{v}}\\right) = 5 - 0 = {lim_minf}$

::: {{.callout-note}}
Cuando $v \\to \\pm\\infty$, el término $\\frac{{1}}{{v}} \\to 0$, por lo que el límite es la constante 5.
:::
"""))

# Problema 4
display(Markdown("""
#### Problema 4: ¿Por qué $\\infty$ no puede ser un límite?

::: {.callout-warning}
## El "Infinito" NO es un Límite

**Razones:**

1. **Definición de límite:** $L$ debe ser un **número real finito**

2. **Vecindades:** Una vecindad se define como un intervalo $(L - \\varepsilon, L + \\varepsilon)$. Como $\\infty$ no es un número, no puede ser centro de una vecindad

3. **Contradicción lógica:** El límite implica **convergencia** a un valor. Si $g(v)$ crece sin límite, **diverge** en lugar de converger

4. **Notación abusiva:** Escribimos $\\lim_{v \\to N} g(v) = \\infty$ solo como conveniencia para indicar que "g(v) crece sin límite", pero técnicamente el límite **no existe**

**Conclusión:** Cuando decimos que una función "tiende a infinito", estamos diciendo que el límite **no existe** (porque no converge a ningún valor finito).
:::
"""))
```

## Ejercicio 6.5: Desigualdades y Valores Absolutos
```{python}
display(Markdown("### Ejercicio 6.5"))

# Problema 1
display(Markdown("#### Problema 1: Resolver desigualdades"))

x = symbols('x', real=True)

# (a) 3x + 1 > 7x - 2
ineq_a = 3*x + 1 > 7*x - 2
sol_a = solve(ineq_a, x)

display(Markdown(f"""
**(a)** $3x + 1 > 7x - 2$

Solución:
1. $3x - 7x > -2 - 1$
2. $-4x > -3$
3. $x < \\frac{{3}}{{4}}$ (invertir desigualdad al dividir por negativo)

**Respuesta:** $x < 0.75$
"""))

# (b) 2x + 5 < x - 4
ineq_b = 2*x + 5 < x - 4
sol_b = solve(ineq_b, x)

display(Markdown(f"""
**(b)** $2x + 5 < x - 4$

Solución:
1. $2x - x < -4 - 5$
2. $x < -9$

**Respuesta:** $x < -9$
"""))

# (c) 5x - 1 < x + 3
ineq_c = 5*x - 1 < x + 3
sol_c = solve(ineq_c, x)

display(Markdown(f"""
**(c)** $5x - 1 < x + 3$

Solución:
1. $5x - x < 3 + 1$
2. $4x < 4$
3. $x < 1$

**Respuesta:** $x < 1$
"""))

# (d) 2x - 1 < 6x + 5
ineq_d = 2*x - 1 < 6*x + 5
sol_d = solve(ineq_d, x)

display(Markdown(f"""
**(d)** $2x - 1 < 6x + 5$

Solución:
1. $2x - 6x < 5 + 1$
2. $-4x < 6$
3. $x > -\\frac{{3}}{{2}}$ (invertir desigualdad)

**Respuesta:** $x > -1.5$
"""))

# Problema 2
display(Markdown("""
#### Problema 2: Desigualdad continua

Dadas: $x - 3 > 0$ y $x - 8 < 0$

**Solución:**
- De $x - 3 > 0$: $x > 3$
- De $x - 8 < 0$: $x < 8$

**Desigualdad continua:** $3 < x < 8$

**Intervalo:** $(3, 8)$
"""))

# Problema 3
display(Markdown("#### Problema 3: Valores absolutos"))

# (a) |x| < 6
display(Markdown("""
**(a)** $|x| < 6$

Eliminar valor absoluto: $-6 < x < 6$

**Respuesta:** $x \\in (-6, 6)$
"""))

# (b) |x + 3| < 2
display(Markdown("""
**(b)** $|x + 3| < 2$

Solución:
1. $-2 < x + 3 < 2$
2. $-2 - 3 < x < 2 - 3$
3. $-5 < x < -1$

**Respuesta:** $x \\in (-5, -1)$
"""))

# (c) |2x - 3| ≤ 5
display(Markdown("""
**(c)** $|2x - 3| \\leq 5$

Solución:
1. $-5 \\leq 2x - 3 \\leq 5$
2. $-5 + 3 \\leq 2x \\leq 5 + 3$
3. $-2 \\leq 2x \\leq 8$
4. $-1 \\leq x \\leq 4$

**Respuesta:** $x \\in [-1, 4]$
"""))

# Visualización
fig, axes = plt.subplots(1, 3, figsize=(15, 4))

# (a)
ax = axes[0]
ax.plot([-6, 6], [0, 0], 'b-', linewidth=3)
ax.plot([-6, 6], [0, 0], 'bo', markersize=8)
ax.set_xlim(-8, 8)
ax.set_ylim(-0.5, 0.5)
ax.axhline(y=0, color='k', linewidth=0.5)
ax.set_title('(a) $|x| < 6$')
ax.set_xlabel('$x$')
ax.grid(True, alpha=0.3)

# (b)
ax = axes[1]
ax.plot([-5, -1], [0, 0], 'b-', linewidth=3)
ax.plot([-5, -1], [0, 0], 'bo', markersize=8)
ax.set_xlim(-7, 1)
ax.set_ylim(-0.5, 0.5)
ax.axhline(y=0, color='k', linewidth=0.5)
ax.set_title('(b) $|x + 3| < 2$')
ax.set_xlabel('$x$')
ax.grid(True, alpha=0.3)

# (c)
ax = axes[2]
ax.plot([-1, 4], [0, 0], 'b-', linewidth=3)
ax.plot([-1], [0], 'bo', markersize=8, markerfacecolor='b')
ax.plot([4], [0], 'bo', markersize=8, markerfacecolor='b')
ax.set_xlim(-3, 6)
ax.set_ylim(-0.5, 0.5)
ax.axhline(y=0, color='k', linewidth=0.5)
ax.set_title('(c) $|2x - 3| \\leq 5$')
ax.set_xlabel('$x$')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Ejercicio 6.6: Teoremas de Límites
```{python}
display(Markdown("### Ejercicio 6.6"))

v = symbols('v')

# Problema 1
display(Markdown("#### Problema 1: $q = 7 - 9v + v^2$"))

q1 = 7 - 9*v + v**2

lim_0 = limit(q1, v, 0)
lim_3 = limit(q1, v, 3)

display(Markdown(f"""
Esta es una función **polinomial**, por lo que podemos usar sustitución directa:

**(a)** $\\lim_{{v \\to 0}} q = 7 - 9(0) + (0)^2 = {lim_0}$

**(b)** $\\lim_{{v \\to 3}} q = 7 - 9(3) + (3)^2 = 7 - 27 + 9 = {lim_3}$
"""))

# Problema 2
display(Markdown("#### Problema 2: $q = (v + 2)(v - 3)$"))

q2 = (v + 2) * (v - 3)

lim_1 = limit(q2, v, 1)
lim_0_2 = limit(q2, v, 0)

display(Markdown(f"""
Usando el **teorema del producto de límites**:

**(a)** $\\lim_{{v \\to 1}} [(v+2)(v-3)] = \\lim_{{v \\to 1}} (v+2) \\cdot \\lim_{{v \\to 1}} (v-3)$
$$= (1+2)(1-3) = (3)(-2) = {lim_1}$$

**(b)** $\\lim_{{v \\to 0}} [(v+2)(v-3)] = (0+2)(0-3) = (2)(-3) = {lim_0_2}$$
"""))

# Problema 3
display(Markdown("#### Problema 3: $q = (3v + 5)(v + 2)$"))

q3 = (3*v + 5) * (v + 2)

lim_0_3 = limit(q3, v, 0)
lim_5 = limit(q3, v, 5)

display(Markdown(f"""
Aplicando el **teorema del producto**:

**(a)** $\\lim_{{v \\to 0}} [(3v+5)(v+2)] = (3(0)+5)(0+2) = (5)(2) = {lim_0_3}$

**(b)** $\\lim_{{v \\to 5}} [(3v+5)(v+2)] = (3(5)+5)(5+2) = (20)(7) = {lim_5}$
"""))

# Crear tabla resumen
summary_data = []
for func_name, func, points in [
    ('$7 - 9v + v^2$', q1, [0, 3]),
    ('$(v+2)(v-3)$', q2, [1, 0]),
    ('$(3v+5)(v+2)$', q3, [0, 5])
]:
    for point in points:
        lim_val = limit(func, v, point)
        summary_data.append({
            'Función': func_name,
            'v → ': point,
            'Límite': int(lim_val)
        })

display(HTML(pd.DataFrame(summary_data).to_html(index=False)))

display(Markdown("""
::: {.callout-note}
## Teoremas Aplicados

En estos ejercicios se aplicaron:

1. **Teorema de funciones polinomiales:** $\\lim_{v \\to N} P(v) = P(N)$
2. **Teorema del producto:** $\\lim [f \\cdot g] = (\\lim f)(\\lim g)$
3. **Teorema de funciones lineales:** $\\lim_{v \\to N} (av + b) = aN + b$

Todos estos son casos especiales del hecho fundamental de que las funciones polinomiales son **continuas** en todo su dominio.
:::
"""))
```


## Definición de Diferenciabilidad

```{python}
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import display, Markdown

# Usamos r""" para evitar conflictos con backslashes de LaTeX
texto_intro = r"""
::: {.callout-important}
## Definición: Función Diferenciable
Una función $f(x)$ es **diferenciable** en $x_0$ si existe el límite:
$$f'(x_0) = \lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}$$
Geométricamente, implica una **tangente única** (sin picos).
:::
"""
display(Markdown(texto_intro))

# Gráficas
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

x_vals = np.linspace(-3, 5, 1000)
f_abs = lambda x: np.abs(x - 1) + 1
axes[0].plot(x_vals, f_abs(x_vals), 'b-', label='|x-1|+1')
axes[0].plot(1, 1, 'ro')
axes[0].set_title('Continua pero NO Diferenciable')
axes[0].legend()

x_vals2 = np.linspace(-1, 4, 1000)
f_smooth = lambda x: (x - 1)**2 + 1
axes[1].plot(x_vals2, f_smooth(x_vals2), 'b-', label='(x-1)^2+1')
axes[1].plot(1, 1, 'ro')
# Tangente como array para evitar el ValueError
x_t = np.linspace(-0.5, 2.5, 50)
y_t = np.full_like(x_t, 1.0)
axes[1].plot(x_t, y_t, 'r--', label='m=0')
axes[1].set_title('Continua Y Diferenciable')
axes[1].legend()

plt.tight_layout()
plt.show()

texto_final = r"""
::: {.callout-warning}
## Diferencia Clave
El "pico" en $x=1$ de la izquierda impide una tangente única, mientras que la curva suave de la derecha sí la permite.
:::
"""
display(Markdown(texto_final))
```

## Relación entre Continuidad y Diferenciabilidad

```{python}
import matplotlib.pyplot as plt
from IPython.display import display, Markdown

# 1. Bloque de Teorema (Asegurando el cierre de comillas y paréntesis)
display(Markdown("""
::: {.callout-important}
## Teorema Fundamental

**Relación entre Continuidad y Diferenciabilidad:**

$$\\text{Diferenciable en } x_0 \\quad \\Rightarrow \\quad \\text{Continua en } x_0$$

**Pero NO al revés:**

$$\\text{Continua en } x_0 \\quad \\not\\Rightarrow \\quad \\text{Diferenciable en } x_0$$

### Jerarquía de Propiedades
Diferenciable $\\subset$ Continua $\\subset$ Definida
:::
"""))

# 2. Gráfica de la Jerarquía
fig, ax = plt.subplots(figsize=(7, 5))
circle1 = plt.Circle((0.5, 0.5), 0.4, color='skyblue', alpha=0.3)
circle2 = plt.Circle((0.5, 0.5), 0.25, color='lightgreen', alpha=0.4)
circle3 = plt.Circle((0.5, 0.5), 0.12, color='gold', alpha=0.5)

ax.add_patch(circle1)
ax.add_patch(circle2)
ax.add_patch(circle3)

ax.text(0.5, 0.5, 'Diferenciables', ha='center', weight='bold')
ax.text(0.5, 0.28, 'Continuas', ha='center')
ax.text(0.5, 0.15, 'Definidas', ha='center')

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
plt.show()
```

## Prueba Visual de Continuidad y Diferenciabilidad

```{python}
# Crear prueba interactiva visual
display(Markdown("""
### Prueba Visual: Clasificación de Funciones

A continuación se muestran varios tipos de funciones en puntos críticos:
"""))

fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# 1. Polinomio (diferenciable)
ax = axes[0, 0]
x_vals = np.linspace(-2, 2, 1000)
y_vals = x_vals**3 - x_vals
ax.plot(x_vals, y_vals, 'b-', linewidth=2)
ax.plot(0, 0, 'ro', markersize=10)
ax.set_title('1. $f(x) = x^3 - x$ en $x=0$\n✅ Diferenciable')
ax.grid(True, alpha=0.3)

# 2. Valor absoluto (continua, no diferenciable)
ax = axes[0, 1]
x_vals = np.linspace(-2, 2, 1000)
y_vals = np.abs(x_vals)
ax.plot(x_vals, y_vals, 'b-', linewidth=2)
ax.plot(0, 0, 'ro', markersize=10)
ax.set_title('2. $f(x) = |x|$ en $x=0$\n✅ Continua, ❌ NO diferenciable')
ax.grid(True, alpha=0.3)

# 3. Racional con hueco (ni continua)
ax = axes[0, 2]
x_vals = np.linspace(-2, 2, 1000)
x_vals = x_vals[np.abs(x_vals) > 0.05]
y_vals = (x_vals**2 - 1) / x_vals
ax.plot(x_vals, y_vals, 'b-', linewidth=2)
ax.plot(0, 0, 'wo', markersize=10, markeredgecolor='red', markeredgewidth=2)
ax.set_title('3. $f(x) = \\frac{x^2-1}{x}$ en $x=0$\n❌ NO continua, ❌ NO diferenciable')
ax.set_ylim(-3, 3)
ax.grid(True, alpha=0.3)

# 4. Escalón (discontinua)
ax = axes[1, 0]
x_left = np.linspace(-2, 0, 100)
x_right = np.linspace(0, 2, 100)
ax.plot(x_left, np.zeros_like(x_left), 'b-', linewidth=2)
ax.plot(x_right, np.ones_like(x_right), 'b-', linewidth=2)
ax.plot(0, 0, 'go', markersize=8)
ax.plot(0, 1, 'bs', markersize=8)
ax.set_title('4. Función escalón en $x=0$\n❌ NO continua (salto)')
ax.set_ylim(-0.5, 1.5)
ax.grid(True, alpha=0.3)

# 5. Raíz cúbica (continua, tangente vertical)
ax = axes[1, 1]
x_vals = np.linspace(-2, 2, 1000)
y_vals = np.sign(x_vals) * np.abs(x_vals)**(1/3)
ax.plot(x_vals, y_vals, 'b-', linewidth=2)
ax.plot(0, 0, 'ro', markersize=10)
ax.set_title('5. $f(x) = \\sqrt[3]{x}$ en $x=0$\n✅ Continua, ❌ NO diferenciable\n(tangente vertical)')
ax.grid(True, alpha=0.3)

# 6. Función suave (diferenciable)
ax = axes[1, 2]
x_vals = np.linspace(-2, 2, 1000)
y_vals = np.exp(-x_vals**2)
ax.plot(x_vals, y_vals, 'b-', linewidth=2)
ax.plot(0, 1, 'ro', markersize=10)
# Tangente
x_tang = np.linspace(-1, 1, 50)
y_tang = np.ones_like(x_tang)  # pendiente = 0 en x=0
ax.plot(x_tang, y_tang, 'r--', linewidth=1.5, alpha=0.7)
ax.set_title('6. $f(x) = e^{-x^2}$ en $x=0$\n✅ Diferenciable (tangente única)')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Tabla resumen
classification_df = pd.DataFrame({
    'Función': [
        '$f(x) = x^3 - x$',
        '$f(x) = |x|$',
        '$f(x) = \\frac{x^2-1}{x}$',
        'Función escalón',
        '$f(x) = \\sqrt[3]{x}$',
        '$f(x) = e^{-x^2}$'
    ],
    'Punto': ['$x=0$'] * 6,
    'Definida': ['✅', '✅', '❌', '✅', '✅', '✅'],
    'Continua': ['✅', '✅', '❌', '❌', '✅', '✅'],
    'Diferenciable': ['✅', '❌', '❌', '❌', '❌', '✅'],
    'Razón': [
        'Suave',
        'Pico agudo',
        'No definida',
        'Salto',
        'Tangente vertical',
        'Suave'
    ]
})

display(HTML(classification_df.to_html(index=False, escape=False)))
```

# Resumen del Capítulo

```{python}
display(Markdown("""
## Conceptos Clave

::: {.callout-note}
### 1. Estática Comparativa
- **Objetivo:** Comparar estados de equilibrio "antes" y "después" de un cambio
- **No considera:** El proceso de ajuste ni el tiempo
- **Herramienta:** La derivada (tasa de cambio instantánea)
- **Tipos:** Cualitativo (dirección) y Cuantitativo (magnitud)
:::

::: {.callout-note}
### 2. Cociente de Diferencias y Derivada

**Cociente de diferencias** (tasa promedio):
$$\\frac{\\Delta y}{\\Delta x} = \\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}$$

**Derivada** (tasa instantánea):
$$\\frac{dy}{dx} = f'(x) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$$

**Relación:** Derivada = límite del cociente de diferencias
:::

::: {.callout-note}
### 3. Interpretación Geométrica

- **Cociente de diferencias:** Pendiente de la **secante** (línea entre dos puntos)
- **Derivada:** Pendiente de la **tangente** (línea en un solo punto)
- **Análisis marginal:** En economía, la derivada representa el concepto "marginal"
:::

::: {.callout-note}
### 4. Concepto de Límite

**Definición:** $\\lim_{v \\to N} g(v) = L$ significa que $g(v)$ se aproxima a $L$ cuando $v$ se acerca a $N$

**Límites laterales:**
- Izquierdo: $v \\to N^-$
- Derecho: $v \\to N^+$
- El límite existe si ambos son iguales

**Evaluación:**
- Sustitución directa (si es continua)
- Transformación algebraica (si hay indeterminación)
- Teoremas de límites
:::

::: {.callout-note}
### 5. Continuidad y Diferenciabilidad

**Continuidad en $x_0$:**
1. $f(x_0)$ definida
2. $\\lim_{x \\to x_0} f(x)$ existe
3. $\\lim_{x \\to x_0} f(x) = f(x_0)$

**Diferenciabilidad en $x_0$:**
- Existe $f'(x_0) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$

**Relación:**
$$\\boxed{\\text{Diferenciable} \\Rightarrow \\text{Continua}}$$
$$\\boxed{\\text{Continua} \\not\\Rightarrow \\text{Diferenciable}}$$
:::

## Fórmulas Importantes

| Concepto | Fórmula | Significado |
|----------|---------|-------------|
| Cociente de diferencias | $\\frac{\\Delta y}{\\Delta x} = \\frac{f(x+\\Delta x) - f(x)}{\\Delta x}$ | Tasa de cambio promedio |
| Derivada | $f'(x) = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x}$ | Tasa de cambio instantánea |
| Aproximación lineal | $f(x) \\approx f(x_0) + f'(x_0)(x - x_0)$ | Estimación usando tangente |
| Límite | $\\lim_{v \\to N} g(v) = L$ | Valor al que tiende la función |
| Continuidad | $\\lim_{x \\to x_0} f(x) = f(x_0)$ | Límite = Valor |

## Aplicaciones Económicas

1. **Análisis Marginal:**
   - Costo Marginal = $C'(Q)$
   - Ingreso Marginal = $I'(Q)$
   - Utilidad Marginal = $U'(Q)$

2. **Multiplicadores:**
   - Multiplicador de la inversión: $\\frac{dY}{dI}$
   - Elasticidad: $\\varepsilon = \\frac{dQ}{dP} \\cdot \\frac{P}{Q}$

3. **Optimización:**
   - Condición de primer orden: $f'(x) = 0$
   - Máximo/mínimo según signo de $f''(x)$
"""))
```

# Referencias y Bibliografía

```{python}
display(Markdown("""
## Referencias Principales

::: {.callout-tip icon=false}
## Bibliografía

**Texto Base:**
- Chiang, A. C. & Wainwright, K. (2005). *Fundamental Methods of Mathematical Economics* (4th ed.). McGraw-Hill, Capítulo 6.

**Lecturas Complementarias:**
- Simon, C. P. & Blume, L. (1994). *Mathematics for Economists*. W. W. Norton & Company.
- Sydsæter, K., Hammond, P., Seierstad, A., & Strøm, A. (2008). *Further Mathematics for Economic Analysis* (2nd ed.). Pearson Education.
- Hoy, M., Livernois, J., McKenna, C., Rees, R., & Stengos, T. (2011). *Mathematics for Economics* (3rd ed.). MIT Press.

**Recursos en Línea:**
- Khan Academy: Cálculo Diferencial
- MIT OpenCourseWare: Single Variable Calculus
- Wolfram MathWorld: Calculus and Analysis
:::

## Próximo Capítulo

En el **Capítulo 7** estudiaremos:
- Reglas de derivación
- Derivadas de funciones compuestas (regla de la cadena)
- Derivadas de funciones implícitas
- Derivadas de orden superior
- Aplicaciones a la optimización económica

---

**Documento preparado con:**
- Python 3.x
- SymPy para cálculo simbólico
- Matplotlib para visualizaciones
- Quarto para generación de documentos
"""))
```

```{python}
#| echo: false
# Información final
import sys
from datetime import datetime

print(f"Documento generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"Versión de Python: {sys.version.split()[0]}")
```


